<!DOCTYP html>
<html>
<head>
<meta charset="UTF-8" />
<title>Regular Expression</title>
</head>
<body>
<pre>

基本元字符：
. 匹配任意单个字符
[] 匹配字符集合中的一个字符，集合中的.+等元字符被解释为普通字符，不需要被转义
[^] 对整个字符集合求非
- 定义一个区间（0-9、A-Z、a-z、A-z等ASCII字符）（-只在[]之间作为元字符）
\ 对下一个字符转义（配对的元字符不用作元字符时必须被转义）

空白元字符：
[\b] 退格符
\f 换页符
\n 换行符
\r 回车符
\t 制表符
\v 垂直制表符

类元字符
数字元字符：
\d 数字
\D 非数字

字母数字元字符：
\w [A-Za-z0-9_]
\W [^A-Za-z0-9_]

空白元字符：
\s [\f\n\r\t\v]
\S [^\f\n\r\t\v]

十六进制值：
\x

八进制值：
\0

POSIX字符类：
[:alnum:] [A-Za-z0-9]
[:alpha:] [A-Za-z]
[:blank:] [\t ]
[:cntrl:] ASCII 0-31  ASCII 127
[:digit:] [0-9]
[:graph:] 同[:print:]但不包括空格
[:lower:] [a-z]
[:print:] 可打印字符
[:punct:] 既不属于[:alnum:]也不属于[:cntrl:]的字符
[:space:] [\f\n\r\t\v ]
[:upper:] [A-Z]
[:xdigit:] [A-Fa-f0-9]

+ 匹配一个或多个字符
* 匹配零个或多个字符
? 匹配零个或一个字符

在正则表达式里，\字符永远出现在一个有着特殊含义的字符序列的开头。

\r?\n

{n}     =n
{n,}    >=n
{n1,n2} >=n1 <=n2
\/

*?
+?
{n,}?

(?m)

IP
(((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5]))\).{3}((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5]))

大小写转换：
\l 把下一个字符转换为小写
\L 把后面的字符转换为小写，直到遇见\E为止
\u 把下一个字符转换为大写
\U 把后面的字符转换为大写，直到遇见\E为止
\E 结束\L或\U转换

前后查找：
(?=)  正向前查找
(?!)  负向前查找
(?<=) 正向后查找
(?<!) 负向后查找

grep：
-E, --extended-regexp 扩展正则表达式模式
-G, --basic-regexp 基本正则表达式模式
-P, --perl-regexp Perl正则表达式模式
-o, --only-matching 只显示匹配模式行的相关部分
-v, --invert-match 显示非匹配行
-c, --count 只显示匹配的总行数

JavaScript：
RegExp.exec()
String.match()
String.replace()
String.search()
String.split()
RegExp.test()
g全局搜索
i不区分大小写
m支持多行字符串
s支持单行字符串
x忽略正则表达式模式里的空白字符
$'返回被匹配字符串前的所有字符
$`返回被匹配字符串后的所有字符
$+返回最后一个被匹配的子表达式
$&返回被匹配到的所有字符串
不支持POSIX字符类
不支持\A和\Z


MySQL：
SELECT * FROM table WHERE REGEXP [BINARY] "pattern"



Java：
java.util.regex.Matcher
find()
lookingAt()
matches()
replaceAll()
replaceFirst()


java.util.regex.Pattern
compile()
flags()
matches()
pattern()
split()













</pre>
</body>
</html>
