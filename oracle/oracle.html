<!DOCTYPE html>
<html>
<head>
    <title>Oracle</title>
</head>
<body>
<pre>
Oracle Database 10g SQL
SQL：Structured Query Language 结构化查询语言

SQL*Plus

PL/SQL

关系数据库 表 行 列

PL/SQL Developer显示中文乱码：
SQL> SELECT * FROM v$nls_parameters;
设置环境变量NLS_LANG=SIMPLIFIED CHINESE_CHINA.ZHS16GBK

执行SQL脚本文件
SQL> @ 文件路径名

查看当前登录的用户：
SQL> SELECT user FROM dual;

打开服务器输出
SQL> SET SERVEROUTPUT ON

查看当前用户拥有的角色：
SQL> SELECT * FROM user_role_privs;

查看当前用户拥有的权限：
SQL> SELECT * FROM session_privs;



PL/SQL（Procedural Language/SQL）：

块结构：
[DECLARE
    声明变量语句;
]
BEGIN
    可执行语句;
[EXCEPTION]
    异常处理语句;
END;
/

例：
DECLARE
    -- v_id    INTEGER;
    -- v_name  VARCHAR2(50);
    -- v_price NUMBER(5, 2);
    -- 使用products表中的price列相同的类型
    -- v_price products.price%TYPE;
    v_width  INTEGER;
    v_height INTEGER := 2;
    v_area   INTEGER :=6;
BEGIN
    -- 计算
    v_width := v_area / v_height;
    DBMS_OUTPUT.PUT_LINE('v_width = ' || v_width);
EXCEPTION
    WHEN ZERO_DIVIDE THEN
        DBMS_OUTPUT.PUT_LINE('Division by zero');
END;
/

条件逻辑：可以嵌套使用
IF 条件1 THEN
    语句1;
ELSIF 条件2 THEN
    语句2;
ELSE
    语句3;
END IF;

循环：
简单循环：
LOOP
    语句;
END LOOP;

可以使用EXIT或EXIT WHEN语句结束简单循环。

例：
v_counter := 0;
LOOP
    v_counter := v_counter + 1;
    EXIT WHEN v_counter = 5;
END LOOP;

在Oracle Database 11g中也可以使用CONTINUE或CONTINUE WHEN语句结束循环的当前迭代，CONTINUE或CONTINUE WHEN语句不能跨过过程、函数或方法的边界。

WHILE循环
WHILE 条件 LOOP
    语句;
END LOOP;

例：
v_counter := 0;
WHILE v_counter < 6 LOOP
    v_counter := v_counter + 1;
END LOOP;

FOR循环
FOR 循环变量 IN [REVERSE] 下限值..上限值 LOOP
    语句;
END LOOP;

例：
FOR v_counter IN 1..5 LOOP
    DBMS_OUTPUT.PUT_LINE(v_counter);
END LOOP;

游标：可以使用游标（cursor）获取查询返回的记录。
CURSOR 游标名 IS
    查询语句;

使用游标步骤：
1. 声明一些变量，用于保存记录的列值。
2. 声明游标，并指定查询。
3. 打开游标。
4. 一次从游标中获取一个记录，并将列值存储在声明的变量中。对变量执行操作。
5. 关闭游标。

示例：
SET SERVEROUTPUT ON
DECLARE
    -- 1
    v_id    t.id%TYPE;
    v_name  t.name%TYPE;
    v_price t.price%TYPE;
    -- 2
    CURSOR v_cursor IS
        SELECT id, name, price
        FROM t
        ORDER BY id;
BEGIN
    -- 3
    OPEN v_cursor;
    LOOP
        -- 4
        TETCH v_cursor
        INTO v_id, v_name, v_price;
        EXIT WHEN v_cursor%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE(v_id || ', ' || v_name || ', ' || v_price);
    END LOOP;
    -- 5
    CLOSE v_cursor;
END;
/

利用FOR循环可以访问游标中的记录。当使用FOR循环时，可以不显示地打开和关闭游标，FOR循环会自动执行这些操作。
示例：
SET SERVEROUTPUT ON
DECLARE
    CURSOR v_cursor IS
        SELECT id, name, price
        FROM t
        ORDER BY id;
BEGIN
    FOR v_t IN v_cursor LOOP
        DBMS_OUTPUT.PUT_LINE(v_t.id || ', ' || v_t.name || ', ' || v_t.price);
    END LOOP;
END;
/

可以对游标使用OPEN-FOR语句，将游标分配给不同的查询，更加灵活的处理游标。
示例：
SET SERVEROUTPUT ON
DECLARE
    TYPE t_cursor IS
    REF CURSOR RETURN t%ROWTYPE;
    v_cursor t_cursor;
    v_t t%ROWTYPE;
BEGIN
    OPEN v_cursor FOR
    SELECT * FROM t WHERE id < 5;
    LOOP
        FETCH v_cursor INTO v_t;
        EXIT WHEN v_cursor%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE(v_t.id || ', ' || v_t.name || ', ' || v_t.price);
    END LOOP;
    CLOSE v_cursor;
END;
/

无约束游标：没有返回类型，可以运行任何查询。
示例：
SET SERVEROUTPUT ON
DECLARE
    TYPE t_cursor IF REF CURSOR;
    v_cursor t_cursor;
    v_t1 t1%ROWTYPE;
    v_t2 t2%ROWTYPE;
BEGIN
    OPEN v_cursor FOR
    SELECT * FROM t1 WHERE id < 5;
    LOOP
        FETCH v_cursor INTO v_t1
        EXIT WHEN v_cursor%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE(v_t1.id || ', ' || v_t1.name || ', ' || v_t1.price);
    END LOOP;
    OPEN v_cursor FOR
    SELECT * FROM t2 WHERE id < 3;
    LOOP
        FETCH v_cursor INTO v_t2
        EXIT WHEN v_cursor%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE(v_t2.id || ', ' || v_t2.name || ', ' || v_t2.price);
    END LOOP;
    CLOSE v_cursor;
END;
/

异常：
系统预定义异常
ACCESS_INTO_NULL ORA-06530
CASE_NOT_FOUND ORA-06592
COLLECTION_IS_NULL ORA-06531
CURSOR_ALREADY_OPEN ORA-06511
DUP_VAL_ON_INDEX ORA-00001
INVALID_CURSOR ORA-01001
INVALID_NUMBER ORA-01722
LOGIN_DENIED ORA-01017
NO_DATA_FOUND ORA-01403
NOT_LOGGED_ON ORA-01012
PROGRAM_ERROR ORA-06501
SELF_IS_NULL ORA-30625
STORAGE_ERROR ORA-06500
SUBSCRIPT_BEYOND_COUNT ORA-06533
SUBSCRIPT_OUTSIDE_LIMIT ORA-06532
SYS_INVALID_ROWID ORA-01410
TIMEOUT_ON_RESOURCE ORA-00051
TOO_MANAY_ROWS ORA-01422
VALUE_ERROR ORA-06502
ZERO_DIVIDE ORA-01476

示例：
BEGIN
    DBMS_OUTPUT.PUT_LINE(1 / 0);
EXCEPTION
    WHEN ZERO_DIVIDE THEN
        DBMS_OUTPUT.PUT_LINE('Division by zero');
END;
/

OTHERS异常：可以处理所有异常，必须在EXCEPTION块中所有特定异常之后使用该异常。

过程：
创建过程：
    CREATE [OR REPLACE] PROCEDURE 过程名
    [(参数名 [IN | OUT | IN OUT] 参数类型 [, ...])]
    {IS | AS}
    BEGIN
        过程代码体
    END 过程名;

示例：
CREATE OR REPLACE update_t(
    p_id IN t.id%TYPE,
    p_val IN NUMBER
) AS
    v_count INTEGER;
BEGIN
    SELECT COUNT(*)
    INTO v_count
    FROM t
    WHERE id = p_id;
    IF v_count = 1 THEN
        UPDATE t
        SET price = price * val
        WHERE id = p_id;
        COMMIT;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
END update_t;
/

调用过程：
-- 用位置表示法传递参数
SQL> CALL update_t(1, 2.3);

在Oracle Database 11g中可以使用命名表示法或混合表示法来传递参数。
-- 用命名表示法传递参数
SQL> CALL update_t(p_val => 2.3, p_id => 1);
-- 用混合表示法传递参数时，位置表示法必须在命名表示法之前。
SQL> CALL update_t(1, p_val => 2.3);

获取有关过程的信息：
从user_procedures视图中可以获得有关过程的信息。
从all_procedures中可以获得有关要访问的所有过程的信息。
SQL> SELECT object_name, aggregate, parallel FROM user_procedures WHERE object_name = 'update_t';

删除过程：
SQL> DROP PROCEDURE update_t;

查看过程中的错误：
SQL> SHOW ERRORS


SQL优化：
1. 使用WHERE子句过滤行，WHERE子句中应避免使用函数，否则会增加执行时间。
2. 使用表连接而不是多个查询。查询中必须选择连接顺序，将行较少的表连接到后面。查询中应避免连接复杂的视图，因为这样会导致查询中首先执行的是视图，然后才是实际查询。相反地，要使用表而不是视图编写查询。
3. 执行连接时使用完全限定的列引用（表别名.列名）。因为对列的所有引用包含了表别名，数据库不需要浪费时间去搜索所有表，从而减少了执行时间。
4. 使用CASE表达式而不是多个查询。
5. 添加表索引。索引的缺点是当向表中添加一行时，需要额外花费时间来更改新行的索引。当单个查询检索的行数小于等于表总行数的10%时，建立索引是有用的。建立索引的列应该用于存储范围广泛的值。Oracle数据库自动为表的主键和包含在唯一约束中的列创建索引。当执行分级查询（CONNECT BY）时，应该为START WITH和CONNECT BY子句所引用的列添加索引。对于包含小范围值且查询的WHERE子句频繁使用的列，应该考虑在此列上添加位图索引。
6. 使用WHERE而不是HAVING。WHERE子句用于过滤行，HAVING子句用于过滤行组。先使用WHERE子句过滤行，以避免花费时间去分组应该被过滤掉的行。
    BAD:  SELECT id, AVG(val) FROM t GROUP BY id HAVING id IN (1, 2);
    GOOD: SELECT id, AVG(val) FROM t WHERE id IN (1, 2) GROUP BY id;
7. 使用UNION ALL而不是UNION。UNION ALL用于获得两个查询检索到的所有行，包括重复行；UNION用于获得查询检索到的所有不重复的行，UNION删除重复的行需要一定时间。
8. 使用EXISTS而不是IN。IN用于检查一个值是否包含在列表中，EXISTS用于检查子查询返回行的存在性。在子查询中，EXISTS提供的性能通常比IN提供的性能要好。
    BAD:  SELECT id, name FROM t WHERE id IN (SELECT id FROM t2);
    GOOD: SELECT id, name FROM t outer WHERE EXISTS (SELECT 1 FROM t2 inner WHERE inner.id = outer.id);
9. 使用EXISTS而不是DISTINCT。DISTINCT用于禁止重复行的显示，DISTINCT在排除重复行之前要对检索到的行排序。
    BAD:  SELECT DISTINCT a.id, a.name FROM t1 a, t2 b WHERE a.id = b.id;
    GOOD: SELECT id, name FROM t1 outer WHERE EXISTS (SELECT 1 FROM t2 inner WHERE inner.id = outer.id);
10. 使用GROUPING SETS而不是CUBE。GROUPING SETS提供的性能通常比CUBE提供的性能要好。
11. 使用绑定变量。






</pre>
<body>
</html>
